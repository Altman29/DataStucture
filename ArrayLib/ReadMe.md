数组：
    把数据码成一排,且是同一种类型

    访问，修改，遍历

二次封装称为自己的数组结构:

    索引可以有语义，也可以没有语义

    数组最大的有点:快速查询。scores[2]

    数组最好应用于"索引有语义"的情况。

    插入(add) 获取（get） 设置(set) 打印(toString) 删除(remove)

使数组支持泛型
    声明类的时候添加<E> E 是任意取得 表示类型

完成动态数组
    当前还是Java提供的静态数组，容量是有限的固定的。现在升级为动态数组。使得数组的容量是可伸缩的，称为动态数组。
    原理很简单，假设一个数组容量为四且有四个元素，已经装满。再添加的话就会报错。
    这时，就开创一个新的数组容量大于之前的数组。容量加倍，size不变将old数组所有元素全部放进new数组中，需要循环实现。用new数组取代old数组。
    并把old数组指向新的数组，old的引用指向new的数组。俩个指向同样的控件。所以在执行完后，new的引用就失效了。而old指向了新的。并回收了old的空间。
    其实删除元素时也可以做优化容量的操作。
    resize()


简单的时间复杂度分析(理论分析！！)
    目前位置，都是代码实现。
    这一段，简单的分析一下时间复杂度。

    O(1) , O(n) , O(logn) , O(nlogn) , O(n^2)
    大O描述的是算法的运行时间和输入数据之间的关系

    e.对一个数组中的数据求和
    public static int sum(int[] nums){
        int sum = 0;
        for(int num : nums) sum+= num;
        return sum;
    }
    这个算法就是O(n)的。 n是nums中的元素个数。O(n)就是求和算法运行的时间多少和数组中元素的个数呈线性关系。nums数组中匀速越多，执行时间越长。
    忽略常数， 应该称为 渐进时间复杂度。描述n趋近于无穷的情况。

    添加操作
        addLast(e)      O(1)
        addFirst(e)     O(n) 都要后移
        add(index,e)    O(n/2) = O(n)
        添加操作整体是:O(n)    如果容量满了 还会涉及 resize : O(n)

    删除操作
        removeLast(e)   O(1)
        removeFirst(e)  O(n)
        removeByIndex(index,e) O(n/2) = O(n)
        删除操作整体是:O(n)        resize: O(n)

    修改操作
        set(index ,e )  O(1)   数组的优势。知道索引 可以立即访问到。
        未知索引O(n)或者已知索引O(1)

    查询操作
        get(index)      O(1)
        contains(e)     O(n)
        find(e)         O(n)
        未知索引O(n)或者已知索引O(1)

    索引具有语义是使用数组的场景。



