线性数据结构
    动态数组
    栈
    队列              底层依然是静态数组，靠resize解决固定容量问题

    链表              真正的动态数据结构

链表的重要性
    链表它是最简单的动态数据结构
    更深入的理解引用或者指针
    更深入的理解递归(本身居右递归的特性，只不过循环就能解决普遍问题)
    本身居右功能行，可以辅助组成其他数据结构

LinkedList

    数据存储在"节点"(Node)中
    class Node{
        E e;
        Node next;
    }
    /*
    对于链表而言，它的链表大部分有俩个部分。一个部分存储真正的数据，另一部分，存储一个Node指向下一个节点。想一个火车，每一节火车存储真正的数据，而车厢与
    车厢之间还有连接。 最后的节点存储空，如果一个节点的next为null说明是最后一个节点。
    */

    优点
    真正的动态，不需要处理固定容量的问题。需要存储多少个数据，就生成多少个节点。
    缺点
    丧失了随机访问的能力，就是像给一个索引直接找到对象。
    从底层机制上，数组所开辟的空间，在内存里连续分布的，所以可以直接寻找这个索引对应的偏移，直接计算出相应的数据所存储的内存地址，直接用O(1)的复杂度
    就把这个元素拿出来；但是链表不同，链表是靠next一层一层连接的，所以在计算机的底层，每一个节点所在的内存的位置是不同的，必须靠next一点一点的来找到
    想要找的元素。这就是链表最大的缺点。

数组和链表的对比
    数组最好用用于索引有语意的情况。scores[2]
    最大的有点: 支持快速查询。

    链表不适用于索引有语意的情况。
    最大的有点：动态。

链表添加元素
    在链表头添加元素
    由于数组中有一个size是指向最后一个元素的下一个位置，也就是待添加元素的位置，所以直接添加到末位是直接方便的，因为有size在跟踪数组的尾。
    而对于链表来说，设计了一个head头的一个变量，换句话说有一个变量跟踪链表的头，而没有相应的元素跟踪数组的尾巴，所以链表是在链表头添加元素的。

    假设添加一个新的元素到链表中，添加过程的关键，如何把这个节点挂接在链表中。让新的node的next指向链表的头。称为了新的链表头，然后让head指向
    新的节点，这就完成了以此添加操作，这个函数结束之后node的就没用了。

    在链表中间添加元素
    在"索引"为2的地方添加元素
    关键就是找到要添加的节点的前一个节点，顺序很重要。

为链表设立虚拟头节点
    为链表的添加操作统一了逻辑。
    dummyHead (dummy 虚拟的)虚拟头结点 存储为Null。对用户来讲是不存在。只是为了编写逻辑更方便。
    类似与循环队列的font的使用。

    主要是涉及俩种遍历，一种是从dummyHead开始循环，一种是从dummyHead后一位实际head开始遍历。

链表时间复杂度分析
    添加操作
        addLast(e)          O(n)
        addFirst(e)         O(1)
        add(index,e)        O(n)
    删除操作
        removeLast(e)       O(n)
        removeFirst(e)      O(1)
        remove(index,e)     O(n)
    修改操作
        set(index,e)        O(n)

    查找操作
        get(index)          O(n)
        contains(e)         O(n)



---


使用链表实现栈的数据结构

    Interface Stack<E>                  <---------  LinkedListStack<E>
    void push(E)                        implements
    E pop()
    E peek()
    int getSize()
    boolean isEmpty()

与数组实现的Stack数据结构的差异
    十万级数据量 入栈和出栈操作耗时
    ArrayStack time: 0.066
    LinkedListStack time: 0.02
    十万级比数组实现的栈相比高效一点，因为不涉及数组的扩容的相关操作，LinkedList实现的是真正动态的，但是它是new来操作的。但是也不能准确说那个比较好
    因为不同级别的数据级来说，new和扩容的耗时都是不一样当。因为复杂度的差异不大。

使用链表实现队列

    增 O(n)              如果只对链表头进行操作:O(1)
    删 O(n)              如果只对链表头进行操作:O(1)
    改 O(n)
    查 O(n)              只查找链表头的元素:O(1)

    本来有head属性，现在添加一个tail属性来控制尾部，使得尾部添加元素更方便。但是从tail端删除元素不易。所以根据这些条件，确定tail端为队列
    队首，从tail端添加元素；head端为队列队尾，从head端删除元素。由于要以链表实现队列数据结构，数据的操作都只在链表的一端完成，不涉及链表中间
    位置的操作，所以不适用dummyHead的思路，直接考虑队尾(head端)队首(tail端)来完成。但由于没有dummyHead，需要注意链表为空的情况。

与数组实现的Queue数据结构的差异
    十万级
    ArrayQueue time:7.74
    LoopQueue time:0.03
    LinkedListQueue time:0.03

递归
    链表是一种天然的递归特性的数据结构