哈希表
    从一个简单的问题。LeetCode 387.
    给一个字符串，找到它第一个不重复的字符，并返回它的索引。如果不存在，则返回-1.
    案列:
    s = "leetcode"
    返回0(l)
    s = "loveleetcode"
    返回2(v)

    分析:创建a-z 26个元素的数组。索引为1代表a出现的频率，索引为2代表b出现的频率，以此类推。

    在solution387中完成运算。
    其实 ：
    int[26] freq 就是一个哈希表！！！！让每个字符和一个数字进行映射关系。每个字符都和一个索引相对应。
    a-0,b-1...,z-25. index = ch - 'a'   O(1)的查找操作。
    哈希函数， f(ch)= ch - 'a'.转换成索引的函数。 哈希函数："键"转换成"索引"

    e.
    一个班的学生学号： 1-30
    身份证 110002199800140012
    字符串 学生名称

    如何设计一个哈希函数把字符串(或者浮点或者复杂对象)转换成"索引"就是哈希表中要考虑的问题。 (学习哈希表的第一个关键问题！！！！！！！！！！)

    之前都是一个"键"对应一个"索引".很难保证每一个"键"通过哈希函数的转换对应不同的"索引",俩个不同的"键"通过哈希函数转换成相同的"索引"，
    这就是"哈希冲突"                                                               (如何解决哈希冲突！！！！！第二个关键问题)


    哈希表充分体现了算法设计领域的经典思想：空间换时间！！！！！
    哈希表是时间和空间之间的平衡。
    哈希函数的设计是很重要的。
    "键"通过哈希函数得到的"索引"分布越均匀约好。

哈希函数的设计
    "键"通过哈希函数得到的"索引"分布越均匀约好。

    整型
    小范围的正整数直接使用
    小范围负整数进行偏移   -100~100  --->   0~200

    大整数
    e.身份证 110002199800140012
    通常做法:取模。 比如
    取后四位。等同于 mod(%) 10000 就是 0012.
    问题：这种方法也存在问题，后四位可能出现相同的情况。就是哈希冲突了。
    取后六位。等同于 mod(%) 1000000 就是 140012.      问题： 分布不均匀！   14是日期，永远不会大于31万
    问题：不管是取后4还是后6，都没有利用所有信息。
    solution：模一个素数，  背后的存在数学理论，不深究。

    浮点型
    转成整型处理。由取模处理。

    字符串
    依然转换成成型处理。然后取模。

    复合类型
    Student。还是转成整型处理。取模。

